#!/bin/sh
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Build a static ASN.1 Object Identified (OID) registry
#
# Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
# Written by David Howells (dhowells@redhat.com)
#

#
# Read OID lines and determine the lengths of the encoded data arrays.
#
set -f -- # use "$@" array for data
total_length=0 IFS='.'
while IFS=' 	' read -r line; do
	if [ "${line#OID_[a-z]}" != "$line" ]; then
		name="${line#*_}" name="${name%,*}" oid="${line#*/* }" oid="${oid% */}"
		# shellcheck disable=SC2086
		size="$(set -- $oid; printf '%u' "$(($# - 1))")"
		for c in $oid; do
			# We will base128 encode the number
			: "$((size += c ? $(awk "BEGIN{print int(log($c)/log(2)/7)}") : 0))"
		done
		set -- "$@" "$name:$oid:$total_length"
		: "$((total_length += size))"
	fi
done

#
# Emit the look-up-by-OID index table
#
printf '/*\n * Automatically generated by %s. Do not edit\n */\n\n' "$0"
if [ "$total_length" -le 255 ]; then
	printf 'static const unsigned char oid_index[OID__NR + 1] = {\n'
else
	printf 'static const unsigned short oid_index[OID__NR + 1] = {\n'
fi
for i do
	printf '\t[OID_%s] = %u,\n' "${i%%:*}" "${i##*:}"
done
printf '\t[OID__NR] = %u\n};\n\n' "$total_length"

#
# Encode the OIDs and emit the OID data
#
printf 'static const unsigned char oid_data[%u] = {\n' "$total_length"
for i do
	IFS='.' j=0 i="${i%:*}"
	for c in ${i##*:}; do
		case "$((j += 1))" in
			1) o="$((c * 40))";;
			2) : "$((o += c))";;
			*)
				# Base128 encode the number
				tmp="$((c ? $(awk "BEGIN{print int(log($c)/log(2)/7)+1}") : 1))"
				while [ "$((tmp -= 1))" -gt 0 ]; do
					o="$o.$((c >> tmp * 7 & 127 | 128))"
				done
				o="$o.$((c & 127))"
		esac
	done

	set -- "$@" "${i%:*}:$o"
	shift

	printf '\t'
	printf '%s, ' $o
	printf '\t// %s\n' "${i%:*}"
done
printf '};\n\n'

printf 'static const struct {\n\tunsigned char hash;\n'
printf '\tenum OID oid : %u;\n} oid_search_table[OID__NR] = {' \
	"$(($# <= 255 ? 8 : 16))"

#
# Create a hash value for each OID and build and emit the search index and hash
# value table (ordered by length then hash then content)
#
i=-1
for j do
	IFS='.' 
	# shellcheck disable=SC2086
	count="$(set -- ${j##*:}; printf '%u' "$(($# - 1))")"
	hash="$count"
	set -- # use as array for reversing octet set
	for k in ${j##*:}; do
		: "$((hash += k * 33))"
		set -- "$k" "$@"
	done
	hash="$((hash >> 24 ^ hash >> 16 ^ hash >> 8 ^ hash & 255))"
	IFS=':'
	printf '%u:%s:%s:%u:%s\n' "$hash" "${j##*:}" "${j%%:*}" "$count" "$*"
done | sort -nt: -k1,1 -k4,4 -k5 | while IFS=':' read -r num octets name _; do
	printf '\n\t[%3u] = { %3u, OID_%-35s }, // ' "$((i += 1))" "$num" "$name"
	# shellcheck disable=SC2086
	printf '%02x' $octets
done
printf '\n};\n'
